<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Worms Zone - Rangga</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e27;
            overflow: hidden;
            position: relative;
        }
        
        /* Halaman Start */
        .start-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1e3a 100%);
            z-index: 1000;
        }
        
        .start-page.hidden {
            display: none;
        }
        
        .game-logo {
            font-size: 80px;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-align: center;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 10px rgba(102, 126, 234, 0.5)); }
            to { filter: drop-shadow(0 0 20px rgba(118, 75, 162, 0.8)); }
        }
        
        .game-subtitle {
            font-size: 36px;
            color: #4CAF50;
            margin-bottom: 40px;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        /* Menu Buttons */
        .menu-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .menu-button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.3);
            position: relative;
            overflow: hidden;
            min-width: 200px;
        }
        
        .menu-button:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .menu-button:hover:before {
            left: 100%;
        }
        
        .menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(76, 175, 80, 0.4);
        }
        
        .menu-button.secondary {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            box-shadow: 0 8px 25px rgba(33, 150, 243, 0.3);
        }
        
        .menu-button.secondary:hover {
            box-shadow: 0 12px 35px rgba(33, 150, 243, 0.4);
        }
        
        .menu-button.tertiary {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            box-shadow: 0 8px 25px rgba(255, 152, 0, 0.3);
        }
        
        .menu-button.tertiary:hover {
            box-shadow: 0 12px 35px rgba(255, 152, 0, 0.4);
        }
        
        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1e3a 0%, #0a0e27 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #4CAF50;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 32px;
            color: #4CAF50;
            font-weight: bold;
        }
        
        .close-button {
            background: #f44336;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .close-button:hover {
            background: #d32f2f;
            transform: rotate(90deg);
        }
        
        /* Tutorial Content */
        .tutorial-content {
            color: white;
        }
        
        .tutorial-section {
            margin-bottom: 25px;
        }
        
        .tutorial-section h3 {
            color: #4CAF50;
            font-size: 22px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tutorial-section p {
            font-size: 16px;
            line-height: 1.6;
            margin-left: 35px;
        }
        
        .tutorial-image {
            width: 100%;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #aaa;
        }
        
        /* Rules Content */
        .rules-content {
            color: white;
        }
        
        .rule-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #4CAF50;
        }
        
        .rule-item h4 {
            color: #4CAF50;
            margin-bottom: 8px;
            font-size: 18px;
        }
        
        .rule-item p {
            font-size: 15px;
            line-height: 1.5;
        }
        
        /* Snake Selection */
        .snake-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .snake-option {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid transparent;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .snake-option:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .snake-option.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .snake-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 10px;
            position: relative;
        }
        
        .snake-preview::before {
            content: '👁️👁️';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
        }
        
        .snake-name {
            color: white;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .snake-description {
            color: #aaa;
            font-size: 12px;
        }
        
        /* Halaman Game */
        .game-page {
            display: none;
        }
        
        .game-page.active {
            display: block;
        }
        
        #gameCanvas {
            display: block;
            background: #0a0e27;
            cursor: crosshair;
        }
        
        /* UI Overlay */
        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        
        .game-ui > * {
            pointer-events: auto;
        }
        
        /* Top Stats */
        .top-stats {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 30px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }
        
        .stat-icon {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .player-name {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* Minimap */
        .minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #4CAF50;
            border-radius: 15px;
            overflow: hidden;
        }
        
        #minimap {
            width: 100%;
            height: 100%;
        }
        
        /* Leaderboard */
        .leaderboard {
            position: absolute;
            top: 240px;
            right: 20px;
            width: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 15px;
            color: white;
        }
        
        .leaderboard h3 {
            text-align: center;
            margin-bottom: 10px;
            color: #4CAF50;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .leaderboard-rank {
            color: #FFD700;
            font-weight: bold;
        }
        
        /* Virtual Joystick */
        .joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
        }
        
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            opacity: 0.7;
        }
        
        .joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* Boost Button */
        .boost-button {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(240, 147, 251, 0.4);
            transition: all 0.3s;
        }
        
        .boost-button:active {
            transform: scale(0.95);
        }
        
        .boost-button.boosting {
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 4px 20px rgba(240, 147, 251, 0.4); }
            50% { box-shadow: 0 4px 30px rgba(240, 147, 251, 0.8); }
            100% { box-shadow: 0 4px 20px rgba(240, 147, 251, 0.4); }
        }
        
        /* Kill Feed */
        .kill-feed {
            position: absolute;
            top: 100px;
            left: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 10px;
            color: white;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .kill-feed-item {
            padding: 5px;
            margin: 2px 0;
            border-radius: 5px;
            font-size: 14px;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .kill-feed-player {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .kill-feed-victim {
            color: #f44336;
        }
        
        /* Game Over Modal */
        .game-over-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            border: 3px solid #f44336;
            min-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 2000;
        }
        
        .game-over-title {
            font-size: 48px;
            color: #f44336;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .final-stats {
            color: white;
            margin-bottom: 30px;
        }
        
        .final-stat {
            font-size: 20px;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .final-stat-label {
            color: #aaa;
        }
        
        .final-stat-value {
            font-weight: bold;
            color: #4CAF50;
        }
        
        .restart-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
            margin: 0 5px;
        }
        
        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(76, 175, 80, 0.4);
        }
        
        /* Power-up Indicator */
        .power-up-indicator {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 30px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: none;
            border: 2px solid;
            animation: slideUp 0.5s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateX(-50%) translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
        
        /* Level Progress */
        .level-progress {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            overflow: hidden;
        }
        
        .level-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%);
            width: 0%;
            transition: width 0.3s;
        }
        
        .level-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        /* Skin Selector */
        .skin-selector {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .skin-selector h4 {
            color: white;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .skin-options {
            display: flex;
            gap: 10px;
        }
        
        .skin-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .skin-option:hover {
            transform: scale(1.1);
        }
        
        .skin-option.selected {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        /* Death Effect */
        .death-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f44336;
            border-radius: 50%;
            pointer-events: none;
            animation: deathExplode 1s ease-out forwards;
        }
        
        @keyframes deathExplode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), var(--y)) scale(0);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Halaman Start -->
    <div class="start-page" id="startPage">
        <div class="game-logo">🐍 Worms Zone</div>
        <div class="game-subtitle">Rangga</div>
        
        <div class="menu-container">
            <button class="menu-button" onclick="showSnakeSelection()">🐍 Pilih Ular</button>
            <button class="menu-button secondary" onclick="showTutorial()">📚 Tutorial</button>
            <button class="menu-button tertiary" onclick="showRules()">📋 Peraturan</button>
            <button class="menu-button" onclick="startGame()">🎮 Mulai Game</button>
        </div>
    </div>
    
    <!-- Modal Tutorial -->
    <div class="modal" id="tutorialModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">📚 Tutorial Bermain</h2>
                <button class="close-button" onclick="closeModal('tutorialModal')">×</button>
            </div>
            <div class="tutorial-content">
                <div class="tutorial-section">
                    <h3>🎮 Kontrol Permainan</h3>
                    <p><strong>Mobile:</strong> Gunakan analog virtual di pojok kiri bawah untuk menggerakkan ular</p>
                    <p><strong>Desktop:</strong> Gunakan tombol Arrow Keys atau WASD pada keyboard</p>
                    <p><strong>Boost:</strong> Tekan tombol boost (⚡) untuk kecepatan ekstra</p>
                    <div class="tutorial-image">🕹️ Kontrol Analog</div>
                </div>
                
                <div class="tutorial-section">
                    <h3>🍎 Makan dan Tumbuh</h3>
                    <p>Makan makanan berwarna yang tersebar di peta untuk membuat ularmu tumbuh</p>
                    <p>Semakin banyak makanan yang dimakan, semakin panjang ularmu</p>
                    <p>Setiap makanan memberikan poin yang berbeda</p>
                    <div class="tutorial-image">🍎 Makanan = Pertumbuhan</div>
                </div>
                
                <div class="tutorial-section">
                    <h3>⚔️ Sistem Pertarungan</h3>
                    <p>Ular yang lebih panjang bisa membunuh ular yang lebih pendek</p>
                    <p>Syarat: Panjang ular minimal 20% lebih panjang dari lawan</p>
                    <p>Hadiah: Mendapat 1/3 panjang lawan + poin bonus</p>
                    <div class="tutorial-image">⚔️ Battle Royale</div>
                </div>
                
                <div class="tutorial-section">
                    <h3>⚡ Power-up Spesial</h3>
                    <p><strong>Kecepatan Super (⚡):</strong> 2x kecepatan selama 5 detik</p>
                    <p><strong>Mode Dewa (🛡️):</strong> Kebal dari semua serangan 3 detik</p>
                    <p><strong>Magnet Makanan (🧲):</strong> Tarik makanan dari jauh</p>
                    <p><strong>Mode Hantu (👻):</strong> Bisa menembus lawan</p>
                    <p><strong>Skor x2 (x2):</strong> Dapatkan poin ganda</p>
                </div>
                
                <div class="tutorial-section">
                    <h3>🏆 Menjadi Juara</h3>
                    <p>Capai panjang maksimal 1000 untuk menjadi yang terkuat</p>
                    <p>Kumpulkan kill sebanyak-banyaknya</p>
                    <p>Hindari ular yang lebih besar darimu</p>
                    <p>Gunakan strategi dan power-up dengan bijak</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Peraturan -->
    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">📋 Peraturan Permainan</h2>
                <button class="close-button" onclick="closeModal('rulesModal')">×</button>
            </div>
            <div class="rules-content">
                <div class="rule-item">
                    <h4>🎯 Tujuan Utama</h4>
                    <p>Jadilah ular terpanjang dengan panjang maksimal 1000. Bertahan hidup, makan makanan, dan bunuh lawan untuk mendapatkan poin.</p>
                </div>
                
                <div class="rule-item">
                    <h4>⚔️ Aturan Pertarungan</h4>
                    <p>- Ular bisa membunuh ular lain jika panjangnya minimal 20% lebih panjang</p>
                    <p>- Menyentuh badan lawan yang lebih pendek akan langsung membunuh</p>
                    <p>- Jika menyentuh lawan yang lebih panjang, kamu akan mati</p>
                    <p>- Ular yang mati akan respawn setelah 3 detik</p>
                </div>
                
                <div class="rule-item">
                    <h4>🏆 Sistem Skor</h4>
                    <p>- Makan makanan: 10-50 poin (tergantung ukuran)</p>
                    <p>- Membunuh lawan: 50 poin per panjang lawan</p>
                    <p>- Power-up Skor x2: Kalikan semua poin dengan 2</p>
                    <p>- Leaderboard diupdate secara real-time</p>
                </div>
                
                <div class="rule-item">
                    <h4>🚫 Larangan</h4>
                    <p>- Dilarang keluar dari batas peta (kecuali saat Mode Dewa/Hantu)</p>
                    <p>- Dilarang menabrak tubuh sendiri</p>
                    <p>- Dilarang menggunakan cheat atau program eksternal</p>
                    <p>- Dilarang bermain curang untuk mendapatkan keuntungan</p>
                </div>
                
                <div class="rule-item">
                    <h4>💡 Tips & Strategi</h4>
                    <p>- Fokus makan makanan di awal permainan untuk tumbuh cepat</p>
                    <p>- Hindari area ramai saat masih pendek</p>
                    <p>- Gunakan power-up secara strategis</p>
                    <p>- Manfaatkan Mode Hantu untuk kabur dari bahaya</p>
                    <p>- Kejar lawan yang lebih pendek untuk mendapatkan kill cepat</p>
                </div>
                
                <div class="rule-item">
                    <h4>🎮 Kontrol Tambahan</h4>
                    <p>- Boost memiliki energi terbatas, gunakan dengan bijak</p>
                    <p>- Bisa ganti skin kapan saja selama permainan</p>
                    <p>- Minimap membantu melihat posisi semua pemain</p>
                    <p>- Kill feed menampilkan informasi pertarungan terbaru</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Pemilihan Ular -->
    <div class="modal" id="snakeSelectionModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">🐍 Pilih Ularmu</h2>
                <button class="close-button" onclick="closeModal('snakeSelectionModal')">×</button>
            </div>
            <div class="snake-selection">
                <div class="snake-option" onclick="selectSnake(0)" data-snake="0">
                    <div class="snake-preview" style="background: #4CAF50"></div>
                    <div class="snake-name">Green Python</div>
                    <div class="snake-description">Klasik & Seimbang</div>
                </div>
                <div class="snake-option" onclick="selectSnake(1)" data-snake="1">
                    <div class="snake-preview" style="background: #2196F3"></div>
                    <div class="snake-name">Blue Cobra</div>
                    <div class="snake-description">Cepat & Lincah</div>
                </div>
                <div class="snake-option" onclick="selectSnake(2)" data-snake="2">
                    <div class="snake-preview" style="background: #FF9800"></div>
                    <div class="snake-name">Orange Viper</div>
                    <div class="snake-description">Agresif & Kuat</div>
                </div>
                <div class="snake-option" onclick="selectSnake(3)" data-snake="3">
                    <div class="snake-preview" style="background: #E91E63"></div>
                    <div class="snake-name">Pink Mamba</div>
                    <div class="snake-description">Misterius & Cepat</div>
                </div>
                <div class="snake-option" onclick="selectSnake(4)" data-snake="4">
                    <div class="snake-preview" style="background: #9C27B0"></div>
                    <div class="snake-name">Purple Anaconda</div>
                    <div class="snake-description">Langka & Berbahaya</div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="menu-button" onclick="closeModal('snakeSelectionModal')">Konfirmasi Pilihan</button>
            </div>
        </div>
    </div>
    
    <!-- Halaman Game -->
    <div class="game-page" id="gamePage">
        <canvas id="gameCanvas"></canvas>
        
        <div class="game-ui">
            <div class="player-name">🐍 Rangga</div>
            
            <div class="top-stats">
                <div class="stat-item">
                    <div class="stat-icon">🏆</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon">📏</div>
                    <div class="stat-value" id="length">10</div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon">⭐</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon">💀</div>
                    <div class="stat-value" id="kills">0</div>
                </div>
            </div>
            
            <div class="minimap-container">
                <canvas id="minimap"></canvas>
            </div>
            
            <div class="leaderboard">
                <h3>🏆 Leaderboard</h3>
                <div id="leaderboardList"></div>
            </div>
            
            <div class="kill-feed" id="killFeed"></div>
            
            <div class="skin-selector">
                <h4>Skin</h4>
                <div class="skin-options">
                    <div class="skin-option selected" style="background: #4CAF50" data-skin="0"></div>
                    <div class="skin-option" style="background: #2196F3" data-skin="1"></div>
                    <div class="skin-option" style="background: #FF9800" data-skin="2"></div>
                    <div class="skin-option" style="background: #E91E63" data-skin="3"></div>
                    <div class="skin-option" style="background: #9C27B0" data-skin="4"></div>
                </div>
            </div>
            
            <div class="joystick-container">
                <div class="joystick-base"></div>
                <div class="joystick-stick"></div>
            </div>
            
            <button class="boost-button" id="boostBtn">⚡</button>
            
            <div class="level-progress">
                <div class="level-bar" id="levelBar"></div>
                <div class="level-text" id="levelText">Level 1</div>
            </div>
            
            <div class="power-up-indicator" id="powerUpIndicator"></div>
            
            <div class="game-over-modal" id="gameOverModal">
                <h2 class="game-over-title">Game Over!</h2>
                <div class="final-stats">
                    <div class="final-stat">
                        <span class="final-stat-label">Skor Akhir:</span>
                        <span class="final-stat-value" id="finalScore">0</span>
                    </div>
                    <div class="final-stat">
                        <span class="final-stat-label">Panjang Maksimal:</span>
                        <span class="final-stat-value" id="finalLength">0</span>
                    </div>
                    <div class="final-stat">
                        <span class="final-stat-label">Level Tercapai:</span>
                        <span class="final-stat-value" id="finalLevel">1</span>
                    </div>
                    <div class="final-stat">
                        <span class="final-stat-label">Total Kill:</span>
                        <span class="final-stat-value" id="finalKills">0</span>
                    </div>
                    <div class="final-stat">
                        <span class="final-stat-label">Waktu Bertahan:</span>
                        <span class="final-stat-value" id="survivalTime">0s</span>
                    </div>
                </div>
                <div>
                    <button class="restart-btn" onclick="restartGame()">Main Lagi</button>
                    <button class="restart-btn" onclick="backToMenu()" style="background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">Menu</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variabel global
        let selectedSnake = 0;
        
        // Fungsi modal
        function showTutorial() {
            document.getElementById('tutorialModal').classList.add('active');
        }
        
        function showRules() {
            document.getElementById('rulesModal').classList.add('active');
        }
        
        function showSnakeSelection() {
            document.getElementById('snakeSelectionModal').classList.add('active');
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }
        
        function selectSnake(snakeIndex) {
            selectedSnake = snakeIndex;
            document.querySelectorAll('.snake-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`[data-snake="${snakeIndex}"]`).classList.add('selected');
        }
        
        // Fungsi untuk memulai game
        function startGame() {
            document.getElementById('startPage').classList.add('hidden');
            document.getElementById('gamePage').classList.add('active');
            initGame();
        }
        
        // Fungsi kembali ke menu
        function backToMenu() {
            document.getElementById('gamePage').classList.remove('active');
            document.getElementById('startPage').classList.remove('hidden');
            document.getElementById('gameOverModal').style.display = 'none';
        }
        
        // Canvas setup
        let canvas, ctx, minimap, minimapCtx;
        
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            minimap = document.getElementById('minimap');
            minimapCtx = minimap.getContext('2d');
            
            // Responsive canvas
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Inisialisasi game
            initGameVariables();
            setupEventListeners();
            gameLoop();
        }
        
        // Game variables
        let gameRunning = true;
        let score = 0;
        let level = 1;
        let kills = 0;
        let gameStartTime = Date.now();
        let camera = { x: 0, y: 0, zoom: 1 };
        
        // Skins
        const skins = [
            { primary: '#4CAF50', secondary: '#8BC34A' },
            { primary: '#2196F3', secondary: '#03A9F4' },
            { primary: '#FF9800', secondary: '#FFC107' },
            { primary: '#E91E63', secondary: '#F06292' },
            { primary: '#9C27B0', secondary: '#BA68C8' }
        ];
        let currentSkin = selectedSnake;
        
        // Player worm
        let player = {
            x: 0,
            y: 0,
            size: 15,
            baseSpeed: 3,
            speed: 3,
            angle: 0,
            body: [],
            length: 10,
            maxLength: 1000,
            skin: selectedSnake,
            boosting: false,
            boostEnergy: 100,
            powerUp: null,
            powerUpTime: 0,
            trail: [],
            kills: 0
        };
        
        // AI worms
        let aiWorms = [];
        const aiNames = ['Snake', 'Python', 'Anaconda', 'Cobra', 'Viper', 'Mamba', 'Krait', 'Adder'];
        
        // Initialize AI worms
        function initAIWorms() {
            aiWorms = [];
            for (let i = 0; i < 8; i++) {
                aiWorms.push({
                    name: aiNames[i],
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 12,
                    speed: 2 + Math.random() * 0.5,
                    angle: Math.random() * Math.PI * 2,
                    body: [],
                    length: 5 + Math.floor(Math.random() * 15),
                    skin: Math.floor(Math.random() * skins.length),
                    targetAngle: Math.random() * Math.PI * 2,
                    changeDirectionTimer: 0,
                    aiLevel: Math.floor(Math.random() * 3) + 1,
                    score: Math.floor(Math.random() * 1000),
                    kills: 0,
                    alive: true,
                    respawnTimer: 0
                });
            }
        }
        
        // Food
        let foods = [];
        const foodCount = 100;
        
        // Power-ups
        let powerUps = [];
        const powerUpTypes = [
            { type: 'speed', color: '#FFD700', duration: 5000, icon: '⚡', effect: 'Kecepatan Super!' },
            { type: 'invincible', color: '#FF6B6B', duration: 3000, icon: '🛡️', effect: 'Mode Dewa!' },
            { type: 'magnet', color: '#4ECDC4', duration: 4000, icon: '🧲', effect: 'Magnet Makanan!' },
            { type: 'ghost', color: '#A8E6CF', duration: 3000, icon: '👻', effect: 'Mode Hantu!' },
            { type: 'multiplier', color: '#FF8B94', duration: 10000, icon: 'x2', effect: 'Skor x2!' }
        ];
        
        // Initialize game variables
        function initGameVariables() {
            gameRunning = true;
            score = 0;
            level = 1;
            kills = 0;
            gameStartTime = Date.now();
            currentSkin = selectedSnake;
            
            // Reset player
            player = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 15,
                baseSpeed: 3,
                speed: 3,
                angle: 0,
                body: [],
                length: 10,
                maxLength: 1000,
                skin: selectedSnake,
                boosting: false,
                boostEnergy: 100,
                powerUp: null,
                powerUpTime: 0,
                trail: [],
                kills: 0
            };
            
            // Initialize food
            foods = [];
            for (let i = 0; i < foodCount; i++) {
                foods.push(createFood());
            }
            
            // Initialize AI worms
            initAIWorms();
            
            // Clear power-ups
            powerUps = [];
            
            // Clear kill feed
            document.getElementById('killFeed').innerHTML = '';
            
            // Update skin selector
            document.querySelectorAll('.skin-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`[data-skin="${selectedSnake}"]`).classList.add('selected');
        }
        
        // Initialize food
        function createFood() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 6 + 3,
                color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                value: Math.floor(Math.random() * 5) + 1,
                pulse: Math.random() * Math.PI * 2
            };
        }
        
        // Virtual joystick
        let joystick = {
            base: null,
            stick: null,
            active: false,
            x: 0,
            y: 0
        };
        
        // Setup event listeners
        function setupEventListeners() {
            joystick.base = document.querySelector('.joystick-base');
            joystick.stick = document.querySelector('.joystick-stick');
            
            // Joystick controls
            joystick.base.addEventListener('touchstart', handleJoystickStart);
            joystick.base.addEventListener('touchmove', handleJoystickMove);
            document.addEventListener('touchend', handleJoystickEnd);
            
            joystick.base.addEventListener('mousedown', handleJoystickStart);
            document.addEventListener('mousemove', handleJoystickMove);
            document.addEventListener('mouseup', handleJoystickEnd);
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Boost button
            const boostBtn = document.getElementById('boostBtn');
            boostBtn.addEventListener('touchstart', () => startBoost());
            boostBtn.addEventListener('mousedown', () => startBoost());
            boostBtn.addEventListener('touchend', () => stopBoost());
            boostBtn.addEventListener('mouseup', () => stopBoost());
            
            // Skin selector
            document.querySelectorAll('.skin-option').forEach(option => {
                option.addEventListener('click', () => {
                    const skinIndex = parseInt(option.dataset.skin);
                    currentSkin = skinIndex;
                    player.skin = skinIndex;
                    
                    document.querySelectorAll('.skin-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');
                });
            });
        }
        
        // Keyboard state
        let keys = {};
        
        // Joystick controls
        function handleJoystickStart(e) {
            joystick.active = true;
            updateJoystick(e);
        }
        
        function handleJoystickMove(e) {
            if (!joystick.active) return;
            updateJoystick(e);
        }
        
        function handleJoystickEnd() {
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            joystick.stick.style.transform = 'translate(-50%, -50%)';
        }
        
        function updateJoystick(e) {
            const rect = joystick.base.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = rect.width / 2 - 30;
            
            if (distance > maxDistance) {
                joystick.x = (deltaX / distance) * maxDistance;
                joystick.y = (deltaY / distance) * maxDistance;
            } else {
                joystick.x = deltaX;
                joystick.y = deltaY;
            }
            
            joystick.stick.style.transform = `translate(calc(-50% + ${joystick.x}px), calc(-50% + ${joystick.y}px))`;
        }
        
        // Boost controls
        function startBoost() {
            if (player.boostEnergy > 0 && !player.boosting) {
                player.boosting = true;
                document.getElementById('boostBtn').classList.add('boosting');
            }
        }
        
        function stopBoost() {
            player.boosting = false;
            document.getElementById('boostBtn').classList.remove('boosting');
        }
        
        // Update player
        function updatePlayer() {
            if (!gameRunning) return;
            
            // Get input from joystick or keyboard
            let inputX = 0, inputY = 0;
            
            if (joystick.active) {
                inputX = joystick.x / 50;
                inputY = joystick.y / 50;
            } else {
                if (keys['ArrowUp'] || keys['w']) inputY = -1;
                if (keys['ArrowDown'] || keys['s']) inputY = 1;
                if (keys['ArrowLeft'] || keys['a']) inputX = -1;
                if (keys['ArrowRight'] || keys['d']) inputX = 1;
            }
            
            // Calculate angle
            if (inputX !== 0 || inputY !== 0) {
                player.angle = Math.atan2(inputY, inputX);
            }
            
            // Calculate speed
            let currentSpeed = player.baseSpeed;
            if (player.powerUp === 'speed') currentSpeed *= 2;
            if (player.boosting && player.boostEnergy > 0) {
                currentSpeed *= 1.5;
                player.boostEnergy -= 1;
            } else {
                if (player.boostEnergy < 100) {
                    player.boostEnergy += 0.2;
                }
            }
            
            // Move player
            player.x += Math.cos(player.angle) * currentSpeed;
            player.y += Math.sin(player.angle) * currentSpeed;
            
            // Add trail effect
            if (player.body.length > 0) {
                player.trail.push({
                    x: player.body[player.body.length - 1].x,
                    y: player.body[player.body.length - 1].y,
                    life: 20
                });
            }
            
            // Update trail
            player.trail = player.trail.filter(t => {
                t.life--;
                return t.life > 0;
            });
            
            // Add to body
            player.body.push({ x: player.x, y: player.y });
            
            // Maintain body length
            while (player.body.length > player.length) {
                player.body.shift();
            }
            
            // Boundary check
            if (player.x < 0 || player.x > canvas.width || player.y < 0 || player.y > canvas.height) {
                if (player.powerUp !== 'invincible' && player.powerUp !== 'ghost') {
                    gameOver();
                } else {
                    // Wrap around
                    player.x = (player.x + canvas.width) % canvas.width;
                    player.y = (player.y + canvas.height) % canvas.height;
                }
            }
            
            // Update power-up
            if (player.powerUp && Date.now() - player.powerUpTime > player.powerUp.duration) {
                player.powerUp = null;
                document.getElementById('powerUpIndicator').style.display = 'none';
            }
            
            // Update camera
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            
            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('length').textContent = Math.min(player.length, player.maxLength);
            document.getElementById('level').textContent = level;
            document.getElementById('kills').textContent = kills;
            
            // Update level progress
            const levelProgress = ((player.length - 10) % 100) / 100 * 100;
            document.getElementById('levelBar').style.width = levelProgress + '%';
            document.getElementById('levelText').textContent = `Level ${level}`;
            
            // Level up
            if (player.length >= 10 + level * 100 && player.length < player.maxLength) {
                level++;
            }
        }
        
        // Update AI worms
        function updateAIWorms() {
            aiWorms.forEach(worm => {
                if (!worm.alive) {
                    worm.respawnTimer--;
                    if (worm.respawnTimer <= 0) {
                        // Respawn worm
                        worm.alive = true;
                        worm.x = Math.random() * canvas.width;
                        worm.y = Math.random() * canvas.height;
                        worm.body = [];
                        worm.length = 5 + Math.floor(Math.random() * 10);
                        worm.angle = Math.random() * Math.PI * 2;
                    }
                    return;
                }
                
                // AI behavior based on level
                if (worm.aiLevel === 1) {
                    // Random movement
                    worm.changeDirectionTimer--;
                    if (worm.changeDirectionTimer <= 0) {
                        worm.targetAngle = Math.random() * Math.PI * 2;
                        worm.changeDirectionTimer = 30 + Math.random() * 60;
                    }
                } else if (worm.aiLevel === 2) {
                    // Seek food or smaller worms
                    let nearestTarget = null;
                    let nearestDistance = Infinity;
                    
                    // Check food
                    foods.forEach(food => {
                        const distance = Math.sqrt(Math.pow(worm.x - food.x, 2) + Math.pow(worm.y - food.y, 2));
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestTarget = { x: food.x, y: food.y, type: 'food' };
                        }
                    });
                    
                    // Check smaller worms
                    [player, ...aiWorms].forEach(otherWorm => {
                        if (otherWorm !== worm && otherWorm.alive && otherWorm.length < worm.length * 0.8) {
                            const distance = Math.sqrt(Math.pow(worm.x - otherWorm.x, 2) + Math.pow(worm.y - otherWorm.y, 2));
                            if (distance < nearestDistance && distance < 200) {
                                nearestDistance = distance;
                                nearestTarget = { x: otherWorm.x, y: otherWorm.y, type: 'worm' };
                            }
                        }
                    });
                    
                    if (nearestTarget && nearestDistance < 200) {
                        worm.targetAngle = Math.atan2(nearestTarget.y - worm.y, nearestTarget.x - worm.x);
                    } else {
                        worm.changeDirectionTimer--;
                        if (worm.changeDirectionTimer <= 0) {
                            worm.targetAngle = Math.random() * Math.PI * 2;
                            worm.changeDirectionTimer = 30 + Math.random() * 60;
                        }
                    }
                } else {
                    // Aggressive AI - hunt smaller worms
                    let nearestTarget = null;
                    let nearestDistance = Infinity;
                    
                    // Prioritize smaller worms
                    [player, ...aiWorms].forEach(otherWorm => {
                        if (otherWorm !== worm && otherWorm.alive && otherWorm.length < worm.length * 0.8) {
                            const distance = Math.sqrt(Math.pow(worm.x - otherWorm.x, 2) + Math.pow(worm.y - otherWorm.y, 2));
                            if (distance < nearestDistance) {
                                nearestDistance = distance;
                                nearestTarget = { x: otherWorm.x, y: otherWorm.y, type: 'worm' };
                            }
                        }
                    });
                    
                    // If no smaller worms, seek food
                    if (!nearestTarget) {
                        foods.forEach(food => {
                            const distance = Math.sqrt(Math.pow(worm.x - food.x, 2) + Math.pow(worm.y - food.y, 2));
                            if (distance < nearestDistance) {
                                nearestDistance = distance;
                                nearestTarget = { x: food.x, y: food.y, type: 'food' };
                            }
                        });
                    }
                    
                    if (nearestTarget) {
                        worm.targetAngle = Math.atan2(nearestTarget.y - worm.y, nearestTarget.x - worm.x);
                    }
                    
                    // Avoid larger worms
                    [player, ...aiWorms].forEach(otherWorm => {
                        if (otherWorm !== worm && otherWorm.alive && otherWorm.length > worm.length * 1.2) {
                            const distance = Math.sqrt(Math.pow(worm.x - otherWorm.x, 2) + Math.pow(worm.y - otherWorm.y, 2));
                            if (distance < 150) {
                                const avoidAngle = Math.atan2(worm.y - otherWorm.y, worm.x - otherWorm.x);
                                worm.targetAngle = avoidAngle;
                            }
                        }
                    });
                }
                
                // Smooth angle transition
                const angleDiff = worm.targetAngle - worm.angle;
                worm.angle += angleDiff * 0.1;
                
                // Move worm
                worm.x += Math.cos(worm.angle) * worm.speed;
                worm.y += Math.sin(worm.angle) * worm.speed;
                
                // Add to body
                worm.body.push({ x: worm.x, y: worm.y });
                
                // Maintain body length
                while (worm.body.length > worm.length) {
                    worm.body.shift();
                }
                
                // Boundary check
                if (worm.x < 0) worm.x = canvas.width;
                if (worm.x > canvas.width) worm.x = 0;
                if (worm.y < 0) worm.y = canvas.height;
                if (worm.y > canvas.height) worm.y = 0;
                
                // Check food collision
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    const distance = Math.sqrt(Math.pow(worm.x - food.x, 2) + Math.pow(worm.y - food.y, 2));
                    
                    if (distance < worm.size + food.size) {
                        foods.splice(i, 1);
                        foods.push(createFood());
                        worm.length += 1;
                        worm.score += food.value * 10;
                        
                        if (worm.length > 100) {
                            worm.length = 10; // Reset AI worm
                            worm.score = 0;
                        }
                    }
                }
            });
        }
        
        // Check collisions and kills
        function checkCollisions() {
            // Player vs food
            for (let i = foods.length - 1; i >= 0; i--) {
                const food = foods[i];
                let distance = Math.sqrt(Math.pow(player.x - food.x, 2) + Math.pow(player.y - food.y, 2));
                
                // Magnet effect
                if (player.powerUp === 'magnet' && distance < 150) {
                    const pullForce = 8;
                    const angle = Math.atan2(player.y - food.y, player.x - food.x);
                    food.x += Math.cos(angle) * pullForce;
                    food.y += Math.sin(angle) * pullForce;
                    distance = Math.sqrt(Math.pow(player.x - food.x, 2) + Math.pow(player.y - food.y, 2));
                }
                
                if (distance < player.size + food.size) {
                    foods.splice(i, 1);
                    foods.push(createFood());
                    
                    let points = food.value * 10;
                    if (player.powerUp === 'multiplier') points *= 2;
                    
                    score += points;
                    
                    if (player.length < player.maxLength) {
                        player.length += 1;
                    }
                }
            }
            
            // Player vs power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                const distance = Math.sqrt(Math.pow(player.x - powerUp.x, 2) + Math.pow(player.y - powerUp.y, 2));
                
                if (distance < player.size + powerUp.size) {
                    powerUps.splice(i, 1);
                    player.powerUp = powerUp.type;
                    player.powerUpTime = Date.now();
                    
                    // Show power-up indicator
                    const indicator = document.getElementById('powerUpIndicator');
                    indicator.textContent = powerUp.icon + ' ' + powerUp.effect;
                    indicator.style.display = 'block';
                    indicator.style.borderColor = powerUp.color;
                    indicator.style.background = powerUp.color + '40';
                }
            }
            
            // Player kills AI worms
            if (player.powerUp !== 'invincible' && player.powerUp !== 'ghost') {
                aiWorms.forEach(worm => {
                    if (!worm.alive) return;
                    
                    worm.body.forEach(segment => {
                        const distance = Math.sqrt(Math.pow(player.x - segment.x, 2) + Math.pow(player.y - segment.y, 2));
                        if (distance < player.size + worm.size) {
                            if (player.length > worm.length * 1.2) {
                                // Player kills worm
                                killWorm(worm, player);
                                player.length += Math.floor(worm.length / 3);
                                score += worm.length * 50;
                                kills++;
                                createDeathEffect(worm.x, worm.y);
                            } else {
                                // Player dies
                                gameOver();
                            }
                        }
                    });
                });
                
                // Check collision with self
                for (let i = 0; i < player.body.length - 20; i++) {
                    const segment = player.body[i];
                    const distance = Math.sqrt(Math.pow(player.x - segment.x, 2) + Math.pow(player.y - segment.y, 2));
                    if (distance < player.size) {
                        gameOver();
                    }
                }
            }
            
            // AI vs AI collisions
            aiWorms.forEach((worm1, i) => {
                if (!worm1.alive) return;
                
                aiWorms.forEach((worm2, j) => {
                    if (i !== j && worm2.alive) {
                        worm2.body.forEach(segment => {
                            const distance = Math.sqrt(Math.pow(worm1.x - segment.x, 2) + Math.pow(worm1.y - segment.y, 2));
                            if (distance < worm1.size + worm2.size) {
                                if (worm1.length > worm2.length * 1.2) {
                                    // Worm1 kills worm2
                                    killWorm(worm2, worm1);
                                    worm1.length += Math.floor(worm2.length / 3);
                                    worm1.score += worm2.length * 50;
                                    worm1.kills++;
                                    createDeathEffect(worm2.x, worm2.y);
                                } else if (worm2.length > worm1.length * 1.2) {
                                    // Worm2 kills worm1
                                    killWorm(worm1, worm2);
                                    worm2.length += Math.floor(worm1.length / 3);
                                    worm2.score += worm1.length * 50;
                                    worm2.kills++;
                                    createDeathEffect(worm1.x, worm1.y);
                                }
                            }
                        });
                    }
                });
            });
        }
        
        // Kill worm function
        function killWorm(victim, killer) {
            victim.alive = false;
            victim.body = [];
            victim.respawnTimer = 180; // 3 seconds at 60fps
            
            // Add to kill feed
            addKillFeed(killer.name || 'Rangga', victim.name);
        }
        
        // Add kill feed message
        function addKillFeed(killer, victim) {
            const killFeed = document.getElementById('killFeed');
            const item = document.createElement('div');
            item.className = 'kill-feed-item';
            item.innerHTML = `<span class="kill-feed-player">${killer}</span> membunuh <span class="kill-feed-victim">${victim}</span>`;
            killFeed.insertBefore(item, killFeed.firstChild);
            
            // Keep only last 5 kills
            while (killFeed.children.length > 5) {
                killFeed.removeChild(killFeed.lastChild);
            }
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (item.parentNode) {
                    item.parentNode.removeChild(item);
                }
            }, 5000);
        }
        
        // Create death effect
        function createDeathEffect(x, y) {
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'death-particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.setProperty('--x', (Math.random() - 0.5) * 200 + 'px');
                particle.style.setProperty('--y', (Math.random() - 0.5) * 200 + 'px');
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    particle.remove();
                }, 1000);
            }
        }
        
        // Spawn power-ups
        function spawnPowerUp() {
            if (Math.random() < 0.003 && powerUps.length < 5) {
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                powerUps.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 25,
                    type: type.type,
                    color: type.color,
                    duration: type.duration,
                    icon: type.icon,
                    effect: type.effect,
                    pulse: 0,
                    rotation: 0
                });
            }
        }
        
        // Draw functions
        function drawWorm(worm, isPlayer = false) {
            if (!isPlayer && !worm.alive) return;
            
            const skin = skins[worm.skin];
            
            // Draw trail
            if (isPlayer && player.trail.length > 0) {
                player.trail.forEach((t, i) => {
                    ctx.globalAlpha = t.life / 20 * 0.3;
                    ctx.beginPath();
                    ctx.arc(t.x - camera.x, t.y - camera.y, worm.size * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = skin.primary;
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
            
            // Draw body with gradient
            for (let i = 0; i < worm.body.length; i++) {
                const segment = worm.body[i];
                const sizeRatio = 1 - (i / worm.body.length) * 0.4;
                const size = worm.size * sizeRatio;
                
                ctx.beginPath();
                ctx.arc(segment.x - camera.x, segment.y - camera.y, size, 0, Math.PI * 2);
                
                if (isPlayer && worm.powerUp === 'invincible') {
                    // Glowing effect
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = skin.primary;
                }
                
                if (isPlayer && worm.powerUp === 'ghost') {
                    ctx.globalAlpha = 0.7;
                }
                
                // Gradient fill
                const gradient = ctx.createRadialGradient(
                    segment.x - camera.x, segment.y - camera.y, 0,
                    segment.x - camera.x, segment.y - camera.y, size
                );
                gradient.addColorStop(0, i === worm.body.length - 1 ? skin.secondary : skin.primary);
                gradient.addColorStop(1, darkenColor(skin.primary, 30));
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                
                // Body outline
                ctx.strokeStyle = darkenColor(skin.primary, 40);
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw eyes
            const head = worm.body[worm.body.length - 1];
            if (head) {
                const eyeOffset = worm.size * 0.4;
                const eyeAngle1 = worm.angle - 0.5;
                const eyeAngle2 = worm.angle + 0.5;
                
                // Eye whites
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(head.x - camera.x + Math.cos(eyeAngle1) * eyeOffset, 
                       head.y - camera.y + Math.sin(eyeAngle1) * eyeOffset, 4, 0, Math.PI * 2);
                ctx.arc(head.x - camera.x + Math.cos(eyeAngle2) * eyeOffset, 
                       head.y - camera.y + Math.sin(eyeAngle2) * eyeOffset, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(head.x - camera.x + Math.cos(eyeAngle1) * eyeOffset, 
                       head.y - camera.y + Math.sin(eyeAngle1) * eyeOffset, 2, 0, Math.PI * 2);
                ctx.arc(head.x - camera.x + Math.cos(eyeAngle2) * eyeOffset, 
                       head.y - camera.y + Math.sin(eyeAngle2) * eyeOffset, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw name and kills
            if (isPlayer || worm.length > 20 || worm.kills > 0) {
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                const nameText = isPlayer ? 'Rangga' : worm.name;
                const killText = worm.kills > 0 ? ` [${worm.kills}💀]` : '';
                ctx.fillText(nameText + killText, head.x - camera.x, head.y - camera.y - worm.size - 10);
            }
        }
        
        function drawFood() {
            foods.forEach(food => {
                food.pulse += 0.1;
                const pulseSize = food.size + Math.sin(food.pulse) * 2;
                
                // Food glow
                ctx.beginPath();
                ctx.arc(food.x - camera.x, food.y - camera.y, pulseSize + 3, 0, Math.PI * 2);
                ctx.fillStyle = food.color + '40';
                ctx.fill();
                
                // Food body
                ctx.beginPath();
                ctx.arc(food.x - camera.x, food.y - camera.y, pulseSize, 0, Math.PI * 2);
                ctx.fillStyle = food.color;
                ctx.fill();
                
                // Food shine
                ctx.beginPath();
                ctx.arc(food.x - camera.x - food.size/3, food.y - camera.y - food.size/3, food.size/3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
            });
        }
        
        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                powerUp.pulse += 0.1;
                powerUp.rotation += 0.02;
                const pulseSize = powerUp.size + Math.sin(powerUp.pulse) * 5;
                
                ctx.save();
                ctx.translate(powerUp.x - camera.x, powerUp.y - camera.y);
                ctx.rotate(powerUp.rotation);
                
                // Outer glow
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize + 10, 0, Math.PI * 2);
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize + 10);
                glowGradient.addColorStop(0, powerUp.color + '60');
                glowGradient.addColorStop(1, powerUp.color + '00');
                ctx.fillStyle = glowGradient;
                ctx.fill();
                
                // Power-up circle
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.fillStyle = powerUp.color;
                ctx.fill();
                
                // Icon
                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerUp.icon, 0, 0);
                
                ctx.restore();
            });
        }
        
        function drawBackground() {
            // Grid pattern
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            
            for (let x = startX; x < camera.x + canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - camera.x, 0);
                ctx.lineTo(x - camera.x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < camera.y + canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - camera.y);
                ctx.lineTo(canvas.width, y - camera.y);
                ctx.stroke();
            }
        }
        
        function drawMinimap() {
            // Clear minimap
            minimapCtx.fillStyle = '#0a0e27';
            minimapCtx.fillRect(0, 0, 200, 200);
            
            const scale = 200 / Math.max(canvas.width, canvas.height);
            
            // Draw foods
            minimapCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            foods.forEach(food => {
                minimapCtx.fillRect(food.x * scale - 1, food.y * scale - 1, 2, 2);
            });
            
            // Draw AI worms
            aiWorms.forEach(worm => {
                if (worm.alive) {
                    minimapCtx.fillStyle = skins[worm.skin].primary;
                    minimapCtx.fillRect(worm.x * scale - 2, worm.y * scale - 2, 4, 4);
                }
            });
            
            // Draw player
            minimapCtx.fillStyle = skins[currentSkin].primary;
            minimapCtx.fillRect(player.x * scale - 3, player.y * scale - 3, 6, 6);
            
            // Minimap border
            minimapCtx.strokeStyle = '#4CAF50';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(0, 0, 200, 200);
        }
        
        function updateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '';
            
            // Create leaderboard data
            const leaderboardData = [
                { name: 'Rangga', score: score, kills: kills, isPlayer: true },
                ...aiWorms.map(worm => ({ name: worm.name, score: worm.score, kills: worm.kills, isPlayer: false }))
            ].sort((a, b) => b.score - a.score).slice(0, 5);
            
            leaderboardData.forEach((entry, index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                const killText = entry.kills > 0 ? ` [${entry.kills}💀]` : '';
                item.innerHTML = `
                    <span class="leaderboard-rank">#${index + 1}</span>
                    <span style="color: ${entry.isPlayer ? '#4CAF50' : 'white'}">${entry.name}${killText}</span>
                    <span>${entry.score}</span>
                `;
                leaderboardList.appendChild(item);
            });
        }
        
        // Helper functions
        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R > 0 ? R : 0) * 0x10000 +
                (G > 0 ? G : 0) * 0x100 +
                (B > 0 ? B : 0)).toString(16).slice(1);
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            const survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLength').textContent = player.length;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('finalKills').textContent = kills;
            document.getElementById('survivalTime').textContent = survivalTime + 's';
            document.getElementById('gameOverModal').style.display = 'block';
        }
        
        // Restart game
        function restartGame() {
            document.getElementById('gameOverModal').style.display = 'none';
            initGameVariables();
        }
        
        // Game loop
        function gameLoop() {
            if (!document.getElementById('gamePage').classList.contains('active')) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Clear canvas
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            drawFood();
            drawPowerUps();
            
            updatePlayer();
            updateAIWorms();
            checkCollisions();
            spawnPowerUp();
            updateLeaderboard();
            
            // Draw worms
            aiWorms.forEach(worm => drawWorm(worm));
            drawWorm(player, true);
            
            // Draw minimap
            drawMinimap();
            
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>